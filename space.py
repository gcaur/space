# -*- coding: utf-8 -*-
"""space

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18LRH2xbaf2KnymmkuEKb5Jjd9X5KjD8u
"""

#radial velocity method
import numpy as np
import matplotlib.pyplot as plt
import emcee

# Simulated radial velocity data
time = np.linspace(0, 10, 100)  # Observational time points
true_params = [1, 2, 0.1]  # True parameters: amplitude, period, eccentricity
observed_rv = true_params[0] * np.sin(2 * np.pi / true_params[1] * time) * (1 + true_params[2] * np.sin(2 * np.pi / true_params[1] * time))

# Model function
def model(params, time):
    return params[0] * np.sin(2 * np.pi / params[1] * time) * (1 + params[2] * np.sin(2 * np.pi / params[1] * time))

# Likelihood function
def log_likelihood(params, time, observed_rv):
    predicted_rv = model(params, time)
    residual = observed_rv - predicted_rv
    chi_sq = np.sum(residual**2)
    return -0.5 * chi_sq

# Prior function
def log_prior(params):
    # Uniform priors for amplitude, period, and eccentricity
    if 0 < params[0] < 10 and 0.1 < params[1] < 10 and 0 < params[2] < 0.5:
        return 0
    return -np.inf

# Posterior function
def log_posterior(params, time, observed_rv):
    return log_prior(params) + log_likelihood(params, time, observed_rv)

# Initial guess for parameters
initial_params = [2, 2, 0.2]

# Initialize and run MCMC sampler
ndim = len(initial_params)
nwalkers = 32
nsteps = 1000
sampler = emcee.EnsembleSampler(nwalkers, ndim, log_posterior, args=(time, observed_rv))
initial_positions = initial_params + 1e-4 * np.random.randn(nwalkers, ndim)
sampler.run_mcmc(initial_positions, nsteps)

# Plot chains
plt.figure(figsize=(10, 6))
for i in range(ndim):
    plt.subplot(ndim, 1, i+1)
    plt.plot(sampler.chain[:,:,i].T, color='k', alpha=0.3)
    plt.ylabel(f'Parameter {i}')
plt.xlabel('Step')
plt.tight_layout()
plt.show()

#\\
#This code simulates radial velocity data and uses the Markov Chain Monte Carlo (MCMC) method to infer the parameters (amplitude, period, and eccentricity) of the underlying sinusoidal signal.

#transit method

# You can use existing packages like batman to model transit light curves and then use emcee for MCMC fitting.

# Example:
import batman
import emcee
import numpy as np

# Simulated transit data
params = batman.TransitParams()
params.t0 = 0.0  # time of inferior conjunction
params.per = 1.0  # orbital period
params.rp = 0.1  # planet radius (in units of stellar radii)
params.a = 15.0  # semi-major axis (in units of stellar radii)
params.inc = 87.0  # orbital inclination (in degrees)
params.ecc = 0.0  # eccentricity
params.w = 90.0  # longitude of periastron (in degrees)
params.u = [0.1, 0.3]  # limb darkening coefficients
params.limb_dark = "quadratic"  # limb darkening model

# Times at which to evaluate the model
t = np.linspace(-0.05, 0.05, 1000)

# Initialize batman model
m = batman.TransitModel(params, t)

# Simulate transit light curve
flux = m.light_curve(params)

# Add noise
flux += np.random.normal(0, 0.001, len(flux))

# Define log likelihood function
def log_likelihood(theta, t, flux):
    params.rp = theta[0]  # planet radius
    params.a = theta[1]   # semi-major axis
    m = batman.TransitModel(params, t)
    model_flux = m.light_curve(params)
    return -0.5 * np.sum((flux - model_flux) ** 2)

# Define log prior function
def log_prior(theta):
    # Flat priors for planet radius and semi-major axis
    if 0 < theta[0] < 0.5 and 10 < theta[1] < 20:
        return 0
    return -np.inf

# Define log posterior function
def log_posterior(theta, t, flux):
    return log_prior(theta) + log_likelihood(theta, t, flux)

# Set up MCMC sampler
ndim = 2
nwalkers = 32
nsteps = 1000
initial_guess = [0.1, 15.0]  # initial guess for planet radius and semi-major axis
pos = [initial_guess + 1e-4 * np.random.randn(ndim) for i in range(nwalkers)]
sampler = emcee.EnsembleSampler(nwalkers, ndim, log_posterior, args=(t, flux))

# Run MCMC sampler
sampler.run_mcmc(pos, nsteps)

# Plot chains
import matplotlib.pyplot as plt
plt.figure(figsize=(10, 6))
for i in range(ndim):
    plt.subplot(ndim, 1, i+1)
    plt.plot(sampler.chain[:,:,i].T, color='k', alpha=0.3)
    plt.ylabel(f'Parameter {i}')
plt.xlabel('Step')
plt.tight_layout()
plt.show()

#microlensing method

# You can use packages like MulensModel or PyLIMA for microlensing modeling and then use emcee for MCMC fitting.

# Example:
import numpy as np
import matplotlib.pyplot as plt
from PyLIMA import event

# Simulated microlensing light curve
t = np.linspace(-30, 30, 1000)
u0, t0, tE, fs, fb = 0.5, 0, 10, 1, 0.1  # parameters of the event
flux = event.pspl(t, u0, t0, tE, fs, fb)

# Add noise
flux += np.random.normal(0, 0.001, len(flux))

# Define log likelihood function
def log_likelihood(theta, t, flux):
    u0, t0, tE, fs, fb = theta
    model_flux = event.pspl(t, u0, t0, tE, fs, fb)
    return -0.5 * np.sum((flux - model_flux) ** 2)

# Define log prior function
def log_prior(theta):
    # Flat priors for all parameters
    if 0 < theta[0] < 1 and -100 < theta[1] < 100 and 0 < theta[2] < 100 and 0 < theta[3] < 10 and 0 < theta[4] < 10:
        return 0
    return -np.inf

# Define log posterior function
def log_posterior(theta, t, flux):
    return log_prior(theta) + log_likelihood(theta, t, flux)

# Set up MCMC sampler
ndim = 5
nwalkers = 32
nsteps = 1000
initial_guess = [0.5, 0, 10, 1, 0.1]  # initial guess for parameters
pos = [initial_guess + 1e-4 * np.random.randn(ndim) for i in range(nwalkers)]
sampler = emcee.EnsembleSampler(nwalkers, ndim, log_posterior, args=(t, flux))

# Run MCMC sampler
sampler.run_mcmc(pos, nsteps)

# Plot chains
plt.figure(figsize=(10, 6))
for i in range(ndim):
    plt.subplot(ndim, 1, i+1)
    plt.plot(sampler.chain[:,:,i].T, color='k', alpha=0.3)
    plt.ylabel(f'Parameter {i}')
plt.xlabel('Step')
plt.tight_layout()
plt.show()


#These examples illustrate how to use statistical analysis and Markov Chain Monte Carlo (MCMC) techniques for different methods of exoplanet detection: radial velocity, transit, and microlensing. Each example includes simulated data, model fitting using MCMC, and visualization of the MCMC chains. You can adapt these examples to your specific needs and datasets.